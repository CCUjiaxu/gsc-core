package org.gsc.core.chain;

import com.google.protobuf.ByteString;
import java.util.List;
import org.gsc.common.exception.BadItemException;
import org.gsc.common.exception.ValidateSignatureException;
import org.gsc.common.utils.Sha256Hash;

public class BlockWrapper extends BlockHeaderWrapper{
  private BlockId blockId;

  private Block block;
  public boolean generatedByMyself = false;

  public BlockWrapper(long number, Sha256Hash hash, long when, ByteString witnessAddress) {
    // blockheader raw

  }

  public BlockWrapper(long number, ByteString hash, long when, ByteString witnessAddress) {
    // blockheader raw

  }

  public BlockWrapper(long timestamp, ByteString parentHash, long number,
      List<TransactionWrapper> transactionList) {

  }

  public void addTransaction(TransactionWrapper pendingTrx) {

  }

  public List<TransactionWrapper> getTransactions() {
    return null;
  }

  public void sign(byte[] privateKey) {

  }

  private Sha256Hash getRawHash() {
    return Sha256Hash.ZERO_HASH;
  }

  public boolean validateSignature() throws ValidateSignatureException {
    return true;
  }

  public BlockId getBlockId() {
    return blockId;
  }

  public Sha256Hash calcMerkleRoot() {
//    List<Transaction> transactionsList = this.block.getTransactionsList();
//
//    if (CollectionUtils.isEmpty(transactionsList)) {
//      return Sha256Hash.ZERO_HASH;
//    }
//
//    Vector<Sha256Hash> ids = transactionsList.stream()
//        .map(TransactionCapsule::new)
//        .map(TransactionCapsule::getHash)
//        .collect(Collectors.toCollection(Vector::new));
//
//    return MerkleTree.getInstance().createTree(ids).getRoot().getHash();
    return Sha256Hash.ZERO_HASH;
  }

  public void setMerkleRoot() {
//    BlockHeader.raw blockHeaderRaw =
//        this.block.getBlockHeader().getRawData().toBuilder()
//            .setTxTrieRoot(calcMerkleRoot().getByteString()).build();
//
//    this.block = this.block.toBuilder().setBlockHeader(
//        this.block.getBlockHeader().toBuilder().setRawData(blockHeaderRaw)).build();
  }


  public BlockWrapper(Block block) {
    this.block = block;
  }

  public BlockWrapper(byte[] data) throws BadItemException {

  }


  public byte[] getData() {
    return null;
  }


  private StringBuffer toStringBuff = new StringBuffer();

  @Override
  public String toString() {
//    toStringBuff.setLength(0);
//
//    toStringBuff.append("BlockWrapper \n[ ");
//    toStringBuff.append("hash=").append(getBlockId()).append("\n");
//    toStringBuff.append("number=").append(getNum()).append("\n");
//    toStringBuff.append("parentId=").append(getParentHash()).append("\n");
//    toStringBuff.append("witness address=")
//        .append(ByteUtil.toHexString(getWitnessAddress().toByteArray())).append("\n");
//
//    toStringBuff.append("generated by myself=").append(generatedByMyself).append("\n");
//    toStringBuff.append("generate time=").append(Time.getTimeString(getTimeStamp())).append("\n");
//
//    AtomicInteger index = new AtomicInteger();
//    if (!getTransactions().isEmpty()) {
//      toStringBuff.append("merkle root=").append(getMerkleRoot()).append("\n");
//      toStringBuff.append("txs size=").append(getTransactions().size()).append("\n");
//      toStringBuff.append("tx: {");
//      getTransactions().forEach(tx -> toStringBuff
//          .append(index.getAndIncrement()).append(":")
//          .append(tx).append("\n"));
//      toStringBuff.append("}");
//    } else {
//      toStringBuff.append("txs are empty\n");
//    }
//    toStringBuff.append("]");
//    return toStringBuff.toString();
    return "";
  }

}
